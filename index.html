<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Medieval Kingdom Builder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #373737;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>    
    <script src="game/core/gameState.js"></script>
    <script src="game/data/buildingData.js"></script>
    <script src="game/systems/saveSystem.js"></script>
    <script src="game/core/config.js"></script>
    <script src="game/scenes/gameScene.js"></script>
    <script src="game/core/main.js"></script>
    <script>
        
        // Game state with save/load functionality


        // Save/Load System



             
             createUpgradeStars(centerX, y, currentLevel, evolution) {
                const elements = [];
                const starSize = 8;
                const starSpacing = 20;
                const startX = centerX - (6 * starSpacing) / 2;
                
                // Create 7 tiers of stars (70 levels total)
                for (let tier = 0; tier < 7; tier++) {
                    const tierColor = evolutionTiers[tier].color;
                    const tierStartLevel = tier * 10;
                    const tierEndLevel = (tier + 1) * 10;
                    
                    // Determine if this tier is accessible
                    const maxLevelForEvolution = evolutionTiers[evolution].maxLevel;
                    const tierAccessible = tierStartLevel < maxLevelForEvolution;
                    
                    // Create star for this tier
                    const starX = startX + tier * starSpacing;
                    const isActive = currentLevel >= tierEndLevel;
                    const isPartiallyFilled = currentLevel > tierStartLevel && currentLevel < tierEndLevel;
                    
                    let fillColor;
                    let alpha = 1.0;
                    
                    if (!tierAccessible) {
                        fillColor = 0x333333; // Dark gray for inaccessible tiers
                        alpha = 0.3;
                    } else if (isActive) {
                        fillColor = tierColor; // Full color when tier is complete
                    } else if (isPartiallyFilled) {
                        fillColor = tierColor; // Same color but we'll add progress indicator
                        alpha = 0.6;
                    } else {
                        fillColor = 0x666666; // Gray for unfilled but accessible
                        alpha = 0.4;
                    }
                    
                    // Create star shape using multiple triangles
                    const star = this.add.star(starX, y, 5, starSize/2, starSize, fillColor);
                    star.setAlpha(alpha);
                    star.setStrokeStyle(1, 0x000000);
                    
                    // Add partial fill indicator for current tier
                    if (isPartiallyFilled) {
                        const progress = (currentLevel - tierStartLevel) / 10;
                        const progressBar = this.add.rectangle(
                            starX, y + starSize + 3, 
                            starSize * 1.5 * progress, 2, 
                            tierColor
                        );
                        elements.push(progressBar);
                    }
                    
                    // Make interactive for tooltips
                    star.setInteractive();
                    star.on('pointerover', () => {
                        if (tierAccessible) {
                            this.showStarTooltip(starX, y - 15, tier, currentLevel, tierStartLevel, tierEndLevel);
                        }
                    });
                    star.on('pointerout', () => {
                        this.hideStarTooltip();
                    });
                    
                    elements.push(star);
                }
                
                // Add level text below stars
                const levelText = this.add.text(centerX, y + 20, `Level: ${currentLevel}/${evolutionTiers[evolution].maxLevel}`, {
                    fontSize: '10px',
                    fill: '#D4B896',
                    fontFamily: 'Courier New'
                }).setOrigin(0.5);
                elements.push(levelText);
                
                return { elements };
            }

            showStarTooltip(x, y, tier, currentLevel, tierStart, tierEnd) {
                this.hideStarTooltip();
                
                const tierName = `Tier ${tier + 1}`;
                const levelRange = `${tierStart + 1}-${tierEnd}`;
                const status = currentLevel >= tierEnd ? 'Complete' : 
                              currentLevel > tierStart ? `${currentLevel - tierStart}/10` : 
                              'Locked';
                
                this.starTooltip = this.add.text(x, y, `${tierName}\nLevels ${levelRange}\n${status}`, {
                    fontSize: '10px',
                    fill: '#FFFFFF',
                    fontFamily: 'Courier New',
                    backgroundColor: '#000000',
                    padding: { x: 4, y: 2 },
                    align: 'center'
                }).setOrigin(0.5);
            }

            hideStarTooltip() {
                if (this.starTooltip) {
                    this.starTooltip.destroy();
                    this.starTooltip = null;
                }
            }

            canAffordCost(cost) {
                for (let resource in cost) {
                    if (gameState.resources[resource] < cost[resource]) {
                        return false;
                    }
                }
                return true;
            }

            formatCost(cost) {
                const parts = [];
                for (let resource in cost) {
                    parts.push(`${cost[resource]} ${resource.charAt(0)}`);
                }
                return parts.join(', ');
            }

            purchaseSpeedUpgrade(plotIndex) {
                const plot = gameState.plots[plotIndex];
                const buildingDef = buildingTypes[plot.building];
                const cost = UpgradeSystem.getSpeedUpgradeCost(buildingDef.baseId, plot.speedLevel);
                
                if (gameState.resources.food >= cost) {
                    gameState.resources.food -= cost;
                    plot.speedLevel++;
                    UpgradeSystem.applyUpgrades(plot);
                    
                    this.updateUI();
                    this.hideUpgradeMenu();
                    this.recreatePlotVisual(plotIndex);
                }
            }

            purchaseOutputUpgrade(plotIndex) {
                const plot = gameState.plots[plotIndex];
                const buildingDef = buildingTypes[plot.building];
                const cost = UpgradeSystem.getOutputUpgradeCost(buildingDef.baseId, plot.outputLevel);
                
                if (gameState.resources.food >= cost) {
                    gameState.resources.food -= cost;
                    plot.outputLevel++;
                    UpgradeSystem.applyUpgrades(plot);
                    
                    this.updateUI();
                    this.hideUpgradeMenu();
                    this.recreatePlotVisual(plotIndex);
                }
            }

            purchaseAutomation(plotIndex) {
                const plot = gameState.plots[plotIndex];
                
                if (gameState.resources.automationTokens >= 1) {
                    gameState.resources.automationTokens--;
                    plot.hasAutomation = true;
                    UpgradeSystem.applyUpgrades(plot);
                        // Evolution tier colors and names



            

                // And modify harvestBuilding method:
                harvestBuilding(plotIndex) {
                    const plot = gameState.plots[plotIndex];
                    if (!plot.building || !plot.harvestReady) return;
                    
                    const buildingDef = buildingTypes[plot.building];
                    
                    // Apply starvation penalty to output if starving
                    const starvationMultiplier = gameState.isStarving ? 0.5 : 1;
                    
                    // Add resources (with starvation penalty and upgrade multipliers)
                    Object.keys(buildingDef.produces).forEach(resource => {
                        const baseAmount = buildingDef.produces[resource];
                        const finalAmount = Math.floor(baseAmount * plot.harvestMultiplier * starvationMultiplier);
                        gameState.resources[resource] += finalAmount;
                    });
                    
                    // Reset harvest timer (with starvation penalty and upgrade speed multipliers)
                    const baseHarvestTime = buildingDef.harvestTime;
                    const starvationTimeMultiplier = gameState.isStarving ? 2 : 1;
                    const harvestTime = Math.floor(baseHarvestTime * starvationTimeMultiplier / plot.productionSpeed);
                    
                    plot.nextHarvest = Date.now() + harvestTime;
                    plot.harvestReady = false;
                    
                    // Remove harvest indicator and progress bar
                    const gridSprite = this.gridSprites[plotIndex];
                    if (gridSprite.harvestIndicator) {
                        gridSprite.harvestIndicator.destroy();
                        gridSprite.harvestIndicator = null;
                    }
                    if (gridSprite.progressBar) {
                        gridSprite.progressBar.destroy();
                        gridSprite.progressBg.destroy();
                        gridSprite.progressBar = null;
                        gridSprite.progressBg = null;
                    }
                    
                    this.updateUI();
                    SaveSystem.autoSave(); // Save after harvest
                }

            updateBuildings() {
                const currentTime = Date.now();
                
                gameState.plots.forEach((plot, index) => {
                    const gridSprite = this.gridSprites[index];
                    
                    if (plot.building && plot.unlocked) {
                        const buildingDef = buildingTypes[plot.building];
                        const timeRemaining = plot.nextHarvest - currentTime;
                        
                        if (timeRemaining <= 0 && !plot.harvestReady) {
                            // Ready to harvest
                            plot.harvestReady = true;
                            
                            // Show harvest indicator
                            if (!gridSprite.harvestIndicator) {
                                gridSprite.harvestIndicator = this.add.circle(
                                    gridSprite.base.x, 
                                    gridSprite.base.y, 
                                    35, 
                                    0xFFFF00, 
                                    0.3
                                );
                            }
                            
                            // Hide progress bar
                            if (gridSprite.progressBar) {
                                gridSprite.progressBar.destroy();
                                gridSprite.progressBg.destroy();
                                gridSprite.progressBar = null;
                                gridSprite.progressBg = null;
                            }
                        } else if (timeRemaining > 0 && !plot.harvestReady) {
                            // Show progress bar
                            const progress = 1 - (timeRemaining / buildingDef.harvestTime);
                            
                            if (!gridSprite.progressBg) {
                                // Create progress bar background
                                gridSprite.progressBg = this.add.rectangle(
                                    gridSprite.base.x, 
                                    gridSprite.base.y + 35, 
                                    50, 6, 
                                    0x333333
                                );
                                gridSprite.progressBg.setStrokeStyle(1, 0x000000);
                            }
                            
                            if (gridSprite.progressBar) {
                                gridSprite.progressBar.destroy();
                            }
                            
                            // Create progress bar fill
                            const barWidth = Math.max(2, 48 * progress);
                            gridSprite.progressBar = this.add.rectangle(
                                gridSprite.base.x - 24 + barWidth/2, 
                                gridSprite.base.y + 35, 
                                barWidth, 4, 
                                0x00FF00
                            );
                        }
                    }
                });
            }

            updateUI() {
                this.uiElements.foodText.setText(`Food: ${gameState.resources.food}`);
                this.uiElements.woodText.setText(`Wood: ${gameState.resources.wood}`);
                this.uiElements.goldText.setText(`Gold: ${gameState.resources.gold}`);
                this.uiElements.popText.setText(`Population: ${gameState.resources.population}`);
            }
        }

        // Start the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html>